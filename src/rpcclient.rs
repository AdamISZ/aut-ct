use autct::utils::APP_DOMAIN_LABEL;
use toy_rpc::Client;
use autct::config::AutctConfig;

// import everything including the client stub generated by the macro
use autct::rpc::*;
use std::error::Error;
use std::fs;

pub async fn do_request(autctcfg: AutctConfig) -> Result<RPCProofVerifyResponse, Box<dyn Error>>{
    let rpc_port = autctcfg.rpc_port;
    let host: &str= &autctcfg.rpc_host.unwrap();
    let port_str: &str = &rpc_port.unwrap().to_string();
    let addr: String = format!("{}:{}", host, port_str);
    let proof_file_str = autctcfg.proof_file_str.unwrap();
    let buf = fs::read(proof_file_str).unwrap();
    let req: RPCProofVerifyRequest = RPCProofVerifyRequest {
        keyset: autctcfg.keyset.unwrap(),
        user_label: autctcfg.user_string.unwrap(),
        context_label: autctcfg.context_label.unwrap(),
        application_label: String::from_utf8(APP_DOMAIN_LABEL.to_vec()).unwrap(),
        proof: buf,
    };
    let mut client = Client::dial(&addr).await.unwrap();
    client.set_default_timeout(std::time::Duration::from_secs(3));
    let result: RPCProofVerifyResponse = client
    .r_p_c_proof_verifier().verify(req)
    .await
    .unwrap();
    Ok(result)
}

