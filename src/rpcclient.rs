
use toy_rpc::Client;
use crate::config::AutctConfig;
use crate::utils::*;
use base64::prelude::*;

// import everything including the client stub generated by the macro
use crate::rpc::*;
use std::error::Error;
use std::fs;

pub async fn auditverify(autctcfg: AutctConfig) ->
Result<RPCAuditProofVerifyResponse, Box<dyn Error>>{
    let rpc_port = autctcfg.rpc_port;
    let host: &str= &autctcfg.rpc_host.clone().unwrap();
    let port_str: &str = &rpc_port.unwrap().to_string();
    let addr: String = format!("ws://{}:{}", host, port_str);
    let proof_file_str = autctcfg.proof_file_str.clone().unwrap();
    let buf = fs::read(proof_file_str).unwrap();
    // request must specify *only one* context label, keyset:
    let (mut cls, mut kss) = autctcfg.clone()
    .get_context_labels_and_keysets().unwrap();
    if kss.len() != 1 || cls.len() != 1 {
        return Err("You may only specify one context_label:keyset in the request".into())
    }
    let keyset = kss.pop().unwrap();
    let context_label = cls.pop().unwrap();
    let req: RPCAuditProofVerifyRequest = RPCAuditProofVerifyRequest {
        keyset,
        user_label: autctcfg.user_string.unwrap(),
        context_label,
        depth: autctcfg.depth.unwrap(),
        generators_length_log_2: autctcfg.generators_length_log_2.unwrap(),
        // the request does *not* include the audit range, which
        // is hardcoded into the proof serialization
        proof: BASE64_STANDARD.encode(buf),
    };
    let mut client = Client::dial_websocket(&addr).await?;
    client.set_default_timeout(std::time::Duration::from_secs(3));
    let result = client
    .r_p_c_audit_proof_verifier().auditverify(req)
    .await;
    // constructed explicitly to convert the Err type:
    match result {
        Ok(r) => return Ok(r),
        Err(e) => return Err(e.into()),
    } 
}
pub async fn verify(autctcfg: AutctConfig) -> Result<RPCProofVerifyResponse, Box<dyn Error>>{
    let rpc_port = autctcfg.rpc_port;
    let host: &str= &autctcfg.rpc_host.clone().unwrap();
    let port_str: &str = &rpc_port.unwrap().to_string();
    let addr: String = format!("ws://{}:{}", host, port_str);
    let proof_file_str = autctcfg.proof_file_str.clone().unwrap();
    let buf = fs::read(proof_file_str).unwrap();
    // request must specify *only one* context label, keyset:
    let (mut cls, mut kss) = autctcfg.clone()
    .get_context_labels_and_keysets().unwrap();
    if kss.len() != 1 || cls.len() != 1 {
        return Err("You may only specify one context_label:keyset in the request".into())
    }
    let keyset = kss.pop().unwrap();
    let context_label = cls.pop().unwrap();
    let req: RPCProofVerifyRequest = RPCProofVerifyRequest {
        keyset,
        user_label: autctcfg.user_string.unwrap(),
        context_label,
        application_label: String::from_utf8(APP_DOMAIN_LABEL.to_vec()).unwrap(),
        proof: BASE64_STANDARD.encode(buf),
    };
    let mut client = Client::dial_websocket(&addr).await.unwrap();
    client.set_default_timeout(std::time::Duration::from_secs(3));
    let result: RPCProofVerifyResponse = client
    .r_p_c_proof_verifier().verify(req)
    .await
    .unwrap();
    Ok(result)
}

pub async fn createkeys(autctcfg: AutctConfig, password: String) -> 
    Result<RPCCreateKeysResponse, Box<dyn Error>> {
    let rpc_port = autctcfg.rpc_port;
    let host: &str= &autctcfg.rpc_host.clone().unwrap();
    let port_str: &str = &rpc_port.unwrap().to_string();
    let addr: String = format!("ws://{}:{}", host, port_str);
    let req: RPCCreateKeysRequest = RPCCreateKeysRequest {
        bc_network: autctcfg.bc_network.unwrap(),
        privkey_file_loc: autctcfg.privkey_file_str.unwrap(),
        encryption_password: password,
    };
    let mut client = Client::dial_websocket(&addr).await.unwrap();
    client.set_default_timeout(std::time::Duration::from_secs(3));
    let result = client
    .r_p_c_create_keys().createkeys(req)
    .await;
    match result {
        Ok(x) => return Ok(x),
        Err(x) => {
            println!("Error in rpc client prove call: {}", &x);
            return Err(x.into());
        }
    }
}

pub async fn auditprove(autctcfg: AutctConfig) ->
Result<RPCAuditProofResponse, Box<dyn Error>> {
    let rpc_port = autctcfg.rpc_port;
    let host: &str= &autctcfg.rpc_host.clone().unwrap();
    let port_str: &str = &rpc_port.unwrap().to_string();
    let addr: String = format!("ws://{}:{}", host, port_str);

    // request must specify *only one* context label, keyset.
    // This will be checked by the server but we can check it here also.
    let (cls, kss) = autctcfg.clone()
    .get_context_labels_and_keysets().unwrap();
    if kss.len() != 1 || cls.len() != 1 {
        return Err("You may only specify one context_label:keyset in the request".into())
    }
    let req: RPCAuditProofRequest = RPCAuditProofRequest{
        keyset: autctcfg.keysets.unwrap(),
        depth: autctcfg.depth.unwrap(),
        generators_length_log_2: autctcfg.generators_length_log_2.unwrap(),
        user_label: autctcfg.user_string.unwrap(),
        privkeys_values_file_loc: autctcfg.privkey_file_str.unwrap(),
        bc_network: autctcfg.bc_network.unwrap(),
        audit_range_min: autctcfg.audit_range_min.unwrap(),
        audit_range_exponent: autctcfg.audit_range_exponent.unwrap(),
    };
    let mut client = Client::dial_websocket(&addr).await.unwrap();
    // we set a very generous timeout here, this could be a problem
    // that needs addressing until we do proof aggregation
    client.set_default_timeout(std::time::Duration::from_secs(720));
    let result = client
    .r_p_c_audit_prover().audit_prove(req)
    .await;
    match result {
        Ok(x) => return Ok(x),
        Err(x) => {
            println!("Error in rpc client audit prove call: {}", &x);
            return Err(x.into());
        }
    }
}
pub async fn prove(autctcfg: AutctConfig, password: String) -> 
    Result<RPCProverResponse, Box<dyn Error>>{
    let rpc_port = autctcfg.rpc_port;
    let host: &str= &autctcfg.rpc_host.clone().unwrap();
    let port_str: &str = &rpc_port.unwrap().to_string();
    let addr: String = format!("ws://{}:{}", host, port_str);

    // request must specify *only one* context label, keyset.
    // This will be checked by the server but we can check it here also.
    let (cls, kss) = autctcfg.clone()
    .get_context_labels_and_keysets().unwrap();
    if kss.len() != 1 || cls.len() != 1 {
        return Err("You may only specify one context_label:keyset in the request".into())
    }
    let req: RPCProverRequest = RPCProverRequest {
        keyset: autctcfg.keysets.unwrap(),
        depth: autctcfg.depth.unwrap(),
        generators_length_log_2: autctcfg.generators_length_log_2.unwrap(),
        user_label: autctcfg.user_string.unwrap(),
        privkey_file_loc: autctcfg.privkey_file_str.unwrap(),
        bc_network: autctcfg.bc_network.unwrap(),
        encryption_password: password,
    };
    let mut client = Client::dial_websocket(&addr).await.unwrap();
    // we set a very generous timeout for proving requests, though they should
    // usually be in the sub 15s area.
    client.set_default_timeout(std::time::Duration::from_secs(120));
    let result = client
    .r_p_c_prover().prove(req)
    .await;
    match result {
        Ok(x) => return Ok(x),
        Err(x) => {
            println!("Error in rpc client prove call: {}", &x);
            return Err(x.into());
        }
    }
}

